깃은 VCS 버전 컨트롤 시스템

파일의 변화에를 시간에 따라 추적하고 관리한다.
분산버전관리시스템 


git init 
새 저장소를 초기화한다. 
해당 폴더를 깃이 탐색을 시작하게 된다 .

.git 폴더가 생성되어 관리를 하게 되는데 
하위의 폴더 및 파일을 추적한다. 

즉, .git 폴더가 있는 하위 폴더에서는 별도의 git 리포를 만들 수 없음 (이미 최상위 git 리포에 포함되어 있는 상태이기 때문) 



check point =  commit = 스냅샷

커밋은 저장하는 것 

git의 커밋을 3가지의 과정으로 볼 수 있다.

working directory -> staging Area -> repository 

working directory는 실제 코드를 작성하는 폴더 위치 

staging Area 커밋전에 변경사항을 저장하는 공간 

repository는 .git 폴더를 의미한다. 
git commit 이라는 명령어를 입력하게 되면 .git 폴더안에 내용이 저장되게 됨

3가지의 영역으로 나뉘어져있는 이유는 무엇일까?? 

우리가 7개의 파일을 변경을 했는데, 각각 2개의 영역으로 구분해서 커밋을 해야하는 경우가 존재한다. 
그런 경우에는 git add 파일명 명령어를 사용해서 staging area에 저장을 한 뒤 해당 변경 내용만 커밋을 진행할 수 있다. 

그럼 git add 를 진행하지 않은 내용은 아직 working directory에 변경되어있는 상태로 남아있기 때문에 
이것들을 git add 를 사용해서 staging area로 옮기고 다시 커밋을 진행하여 2개의 그룹으로 나눠서 커밋을 진행할 수 있기 때문에 영역이 나뉘어짐 ㅋ


커밋은 원자적으로 유지하기 
한 가지의 기능이나 작업들을 하나의 커밋으로 관리하기 

커밋 메세지 
커밋 메세지는 현재 메세지로 작성하라는게 깃에서 권장하는 방법

git 편집기 설정하기 
git config --global core.editor "code --wait"
git commit 명령어를 입력하면, 커밋 메세지를 작성하도록 git의 디폴트 에디터 (vim)가 실행되는데, 
그 defulat editor를 vs코드로 변경하는 것  --wait가 의미하는 것은 파일을 저장하고 종료하기 까지 명령어를 기다리는 상태로 유지 


git log
커밋의 과정을 볼 수 있음 
 
해쉬id라던가 메세지가 길게되면 보기 불편하니까 여러의 format 옵션을 제공하는데 
그중에서 --oneline을 사용하게 되면, 한 눈에 커밋과정을 볼 수 있음

amending commit 커밋 수정
실수로 커밋에 빼먹은 파일이 존재한다거나, 커밋 메세지를 수정하고 싶은 경우에 사용
단, 바로직전에 실행한 commit 수정만 가능하다.

git commit -m "some commit"
git add file
git commit --amend  새 커밋을 생성해 현재 브랜치를 수정하거나 교차하는 것 


.gitignore
추적에 포함시키지 않도록 파일을 관리한다.
보안적으로 중요한 파일, node모듈같이 복사할 필요가 없는 파일, mac의 DS_Storer(finder가 파일제 접근하면 자동으로생기는 메타데이터 파일)


최상위 루트에 위치시킨다.

.DS_Stroe
secrets.txt
node_modules/   // 맨 마지막에 슬러쉬가 들어가면 디렉토리를 의미한다. 


커밋이력에는 해시값을 가지게 되고, 또 한 이전 커밋에 대한 해시값을 가지고 있어서 직선적으로 연결되어있음 

브랜치
프로젝트의 타임라인같은 기능을한다
별도의 콘텍스트를 생성할 수 있다. 동시에 다양한 작업을 실행할 수 있음
다른 브랜치ㅔ는 전혀 영향을 끼치지 않기 때문에 (서로 별도로 존재한다) 


메인 vs 마스터

마스터 브랜치는 리포를 만드는 순간 자동으로 생성되는 기본 브랜치이다. 
다른 브랜치와 똑같다. 단지, 자동으로 생성된 브랜치일 뿐 
특별한 브랜치가 아니다. 원본을 보관할 필요도없고 삭제해도 된다. 

오랫동안 기본 브랜치는 master 였지만 main으로 변경이 되었따. (github만 git은 아직 master) 


HEAD란? 
git log의 최근 이력에 HEAD -> master 이라는 문구가 있다. 
현재 우리의 위치를 가르키는 포인터이다. 
브랜치 레퍼런스를 가르킨다. 

브랜치를 책갈피라 생각하고, 책갈피는 책에 여러개 존재 가능하다. 
하지만, 책갈피로 책을 펼치게 되면, 딱 그 페이지만을 볼 수 있는데 
이러한 개념이 HEAD가 된다. 

HEAD는 항상 master를 가르키게된다. (지정하지 않으면)

HEAD는 브랜치 포인터이고, 현재 브렌치가 있는 위치이다. (책의 북마크)
여러개의 브랜치를 가질 수 있고 각 브랜치는 브랜치 레퍼런스를 갖고 있다. 

git branch
현재 존재하는 브랜치의 목록을 보여준다.
브랜치의 이름 옆에 *가 붙어있는게 지금 현재 HEAD가 가르키고 있는 브랜치가 된다. 

git branch <branch-name> 
브랜치 생성

git switch <branch-name>
브랜치 전환 


  

