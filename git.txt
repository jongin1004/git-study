깃은 VCS 버전 컨트롤 시스템

파일의 변화에를 시간에 따라 추적하고 관리한다.
분산버전관리시스템 


git init 
새 저장소를 초기화한다. 
해당 폴더를 깃이 탐색을 시작하게 된다 .

.git 폴더가 생성되어 관리를 하게 되는데 
하위의 폴더 및 파일을 추적한다. 

즉, .git 폴더가 있는 하위 폴더에서는 별도의 git 리포를 만들 수 없음 (이미 최상위 git 리포에 포함되어 있는 상태이기 때문) 



check point =  commit = 스냅샷

커밋은 저장하는 것 

git의 커밋을 3가지의 과정으로 볼 수 있다.

working directory -> staging Area -> repository 

working directory는 실제 코드를 작성하는 폴더 위치 

staging Area 커밋전에 변경사항을 저장하는 공간 

repository는 .git 폴더를 의미한다. 
git commit 이라는 명령어를 입력하게 되면 .git 폴더안에 내용이 저장되게 됨

3가지의 영역으로 나뉘어져있는 이유는 무엇일까?? 

우리가 7개의 파일을 변경을 했는데, 각각 2개의 영역으로 구분해서 커밋을 해야하는 경우가 존재한다. 
그런 경우에는 git add 파일명 명령어를 사용해서 staging area에 저장을 한 뒤 해당 변경 내용만 커밋을 진행할 수 있다. 

그럼 git add 를 진행하지 않은 내용은 아직 working directory에 변경되어있는 상태로 남아있기 때문에 
이것들을 git add 를 사용해서 staging area로 옮기고 다시 커밋을 진행하여 2개의 그룹으로 나눠서 커밋을 진행할 수 있기 때문에 영역이 나뉘어짐 ㅋ


커밋은 원자적으로 유지하기 
한 가지의 기능이나 작업들을 하나의 커밋으로 관리하기 

커밋 메세지 
커밋 메세지는 현재 메세지로 작성하라는게 깃에서 권장하는 방법

git 편집기 설정하기 
git config --global core.editor "code --wait"
git commit 명령어를 입력하면, 커밋 메세지를 작성하도록 git의 디폴트 에디터 (vim)가 실행되는데, 
그 defulat editor를 vs코드로 변경하는 것  --wait가 의미하는 것은 파일을 저장하고 종료하기 까지 명령어를 기다리는 상태로 유지 


git log
커밋의 과정을 볼 수 있음 
 
해쉬id라던가 메세지가 길게되면 보기 불편하니까 여러의 format 옵션을 제공하는데 
그중에서 --oneline을 사용하게 되면, 한 눈에 커밋과정을 볼 수 있음

amending commit 커밋 수정
실수로 커밋에 빼먹은 파일이 존재한다거나, 커밋 메세지를 수정하고 싶은 경우에 사용
단, 바로직전에 실행한 commit 수정만 가능하다.

git commit -m "some commit"
git add file
git commit --amend  새 커밋을 생성해 현재 브랜치를 수정하거나 교차하는 것 


.gitignore
추적에 포함시키지 않도록 파일을 관리한다.
보안적으로 중요한 파일, node모듈같이 복사할 필요가 없는 파일, mac의 DS_Storer(finder가 파일제 접근하면 자동으로생기는 메타데이터 파일)


최상위 루트에 위치시킨다.

.DS_Stroe
secrets.txt
node_modules/   // 맨 마지막에 슬러쉬가 들어가면 디렉토리를 의미한다. 


커밋이력에는 해시값을 가지게 되고, 또 한 이전 커밋에 대한 해시값을 가지고 있어서 직선적으로 연결되어있음 

브랜치
프로젝트의 타임라인같은 기능을한다
별도의 콘텍스트를 생성할 수 있다. 동시에 다양한 작업을 실행할 수 있음
다른 브랜치ㅔ는 전혀 영향을 끼치지 않기 때문에 (서로 별도로 존재한다) 


메인 vs 마스터

마스터 브랜치는 리포를 만드는 순간 자동으로 생성되는 기본 브랜치이다. 
다른 브랜치와 똑같다. 단지, 자동으로 생성된 브랜치일 뿐 
특별한 브랜치가 아니다. 원본을 보관할 필요도없고 삭제해도 된다. 

오랫동안 기본 브랜치는 master 였지만 main으로 변경이 되었따. (github만 git은 아직 master) 


HEAD란? 
git log의 최근 이력에 HEAD -> master 이라는 문구가 있다. 
현재 우리의 위치를 가르키는 포인터이다. 
브랜치 레퍼런스를 가르킨다. 

브랜치를 책갈피라 생각하고, 책갈피는 책에 여러개 존재 가능하다. 
하지만, 책갈피로 책을 펼치게 되면, 딱 그 페이지만을 볼 수 있는데 
이러한 개념이 HEAD가 된다. 

HEAD는 항상 master를 가르키게된다. (지정하지 않으면)

HEAD는 브랜치 포인터이고, 현재 브렌치가 있는 위치이다. (책의 북마크)
여러개의 브랜치를 가질 수 있고 각 브랜치는 브랜치 레퍼런스를 갖고 있다. 

git branch
현재 존재하는 브랜치의 목록을 보여준다.
브랜치의 이름 옆에 *가 붙어있는게 지금 현재 HEAD가 가르키고 있는 브랜치가 된다. 

git branch <branch-name> 
브랜치 생성

git switch <branch-name>
브랜치 전환 

git branch -d 브랜치 삭제
-D 대문자를 사용하면 강제 삭제 ( merge를 하지 않은 상태에서 삭제는 할 수 없다고 에러가 나오는데 강제로 하고 싶은 경우 사용) 
* 브랜치를 삭제하기 위해서는 삭제하려는 브랜치가 아닌 다른 브랜치로 switch 상태여야함 

git branch -m <변경할 이름> 이름변경
이름을 변경하기 위해서는 해당 브랜치로 switch 해야함 (delete와는 반대)

  HEAD 
.git/HEAD 에 지금 가르키고 있는 브랜치 정보가 나와있음 
파일 내용을 보면 refs/heads/브랜치명 으로 되어있다. 
그리고 위의 경로를 따라 가보면, 각 브랜치 명마다 파일이 만들어져있고,
그 내용을 확인해보면 해시ID값을 알 수 있다. 

위와같은 방법으로 HEAD가 어떤 커밋을 가르키는지를 알 수 있음 
즉, HEAD는 특정 브랜치를 참조하고, 브랜치는 특정 커밋을 참조한다. 
refs/heads/커밋명 으로 HEAD는 브랜치를 참조 
refs/heads/커밋명 파일안에 있는 해시ID값을 통해서 브랜치는, 특정 커밋을 참조


빨리 감기 병합

1. 브랜치를 병합한다 
2. 항상 형재 브랜치에 병합한다.

병합은 커밋단위로 병합하는 것이아닌 브랜치 단위로 병합을 진행함 
병합하고자하는 브랜치로 먼저 이동을하고 그 대싱 브랜치를 명명함 

bugfix 브랜치를 만들었는데 , master 브랜치에 병합시키고 싶은 경우에는 
git switch master 로 먼저 이동을하고,
git merge bugfix 명령어를 통해 병합을 한다. 

merge 명령어를 이용하게 되면, 기존에 master 브랜치는 가지고 있지 않은 커밋 내용 (bugfix에서 생성한 커밋내용)을 가지게 된다. 
기존에 master 브랜치는 bugfix 브랜치보다 뒤쳐져있는 커밋을 참고하고 있는데 
merge를 함으로써, bugfix가 참조하는 커밋과 동일한 커밋을 참조하게 된다.
이러한 것을 빨리감기 병합이라고 한다 


병합 커밋 
보통은 빨리감기 병합같은 일이 나오진 않는다. 
bugfix 브랜치가 master 브랜치로부터 만들어지고, 수정을해서 커밋을 했는데 
그 과정에서 master도 추가적으로 수정을해 커밋이 이루어진 경우에는 빠른 커밋을 할 수 없다. 

따라서, 새로운 커밋을 만들고, master의 커밋과 bugfix의 커밋 내용을 병합을 시킨다. 
이러한 병합으로 생기는 커밋을 master와 bugfix의 커밋 두개를 부모 커밋으로 가지게 된다. 


git diff를 사용 
서로다른 브랜치, 파일, 폴더 스태이징 에어리어등의 차이점을 비교할 수 있도록 도와주는 명려어


다순 git diff 를 사용하면 working directory와 staging area의 변화를 비교함 

168~169번째의 줄을 추가한 뒤에 git diff 명령어를 사용한 결과

==================================
diff --git a/git.txt b/git.txt
index 403e667..2da10c6 100644
--- a/git.txt
+++ b/git.txt
@@ -164,3 +164,6 @@ bugfix 브랜치가 master 브랜치로부터 만들어지고, 수정을해서
 따라서, 새로운 커밋을 만들고, master의 커밋과 bugfix의 커밋 내용을 병합을 시킨다.
 이러한 병합으로 생기는 커밋을 master와 bugfix의 커밋 두개를 부모 커밋으로 가지게 된다.

+
+git diff를 사용 
+서로다른 브랜치, 파일, 폴더 스태이징 에어리어등의 차이점을 비교할 수 있도록 도와주는 명려어
==================================

위와 같은 결과가 나온다. 
 --- a/git.txt는 스테이징영역에 있는 파일
 +++ b/git.txt는 working directory에 있는 파일 

표현하고 있는 것을 볼 수 있다. 

@@ -164,3 +164,6 @@ 가 의미하는 것 
- 는 앞에 나오는 a/git.txt(변화 전)파일을 가르키고 
+ 는 뒤에 나오는 b/git.txt(변화 후)파일을 가르킨다. 

164번쨰 줄로부터 3줄, 164줄로 부터 6줄을 표시하고 있다는 의미가 된다.



git diff HEAD
마지막 커밋, 가장 나중에 실행된 커밋부터 워킹 디렉토리에 있는 모든 번경사항 목록을 나열해준다.
즉, HEAD가 참조했던 커밋 이후에 변경했던 모든 것을 볼 수 있다.

 