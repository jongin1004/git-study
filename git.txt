깃은 VCS 버전 컨트롤 시스템

파일의 변화에를 시간에 따라 추적하고 관리한다.
분산버전관리시스템 


git init 
새 저장소를 초기화한다. 
해당 폴더를 깃이 탐색을 시작하게 된다 .

.git 폴더가 생성되어 관리를 하게 되는데 
하위의 폴더 및 파일을 추적한다. 

즉, .git 폴더가 있는 하위 폴더에서는 별도의 git 리포를 만들 수 없음 (이미 최상위 git 리포에 포함되어 있는 상태이기 때문) 



check point =  commit = 스냅샷

커밋은 저장하는 것 

git의 커밋을 3가지의 과정으로 볼 수 있다.

working directory -> staging Area -> repository 

working directory는 실제 코드를 작성하는 폴더 위치 

staging Area 커밋전에 변경사항을 저장하는 공간 

repository는 .git 폴더를 의미한다. 
git commit 이라는 명령어를 입력하게 되면 .git 폴더안에 내용이 저장되게 됨

3가지의 영역으로 나뉘어져있는 이유는 무엇일까?? 

우리가 7개의 파일을 변경을 했는데, 각각 2개의 영역으로 구분해서 커밋을 해야하는 경우가 존재한다. 
그런 경우에는 git add 파일명 명령어를 사용해서 staging area에 저장을 한 뒤 해당 변경 내용만 커밋을 진행할 수 있다. 

그럼 git add 를 진행하지 않은 내용은 아직 working directory에 변경되어있는 상태로 남아있기 때문에 
이것들을 git add 를 사용해서 staging area로 옮기고 다시 커밋을 진행하여 2개의 그룹으로 나눠서 커밋을 진행할 수 있기 때문에 영역이 나뉘어짐 ㅋ


커밋은 원자적으로 유지하기 
한 가지의 기능이나 작업들을 하나의 커밋으로 관리하기 

커밋 메세지 
커밋 메세지는 현재 메세지로 작성하라는게 깃에서 권장하는 방법

git 편집기 설정하기 
git config --global core.editor "code --wait"
git commit 명령어를 입력하면, 커밋 메세지를 작성하도록 git의 디폴트 에디터 (vim)가 실행되는데, 
그 defulat editor를 vs코드로 변경하는 것  --wait가 의미하는 것은 파일을 저장하고 종료하기 까지 명령어를 기다리는 상태로 유지 


git log
커밋의 과정을 볼 수 있음 
 
해쉬id라던가 메세지가 길게되면 보기 불편하니까 여러의 format 옵션을 제공하는데 
그중에서 --oneline을 사용하게 되면, 한 눈에 커밋과정을 볼 수 있음

amending commit 커밋 수정
실수로 커밋에 빼먹은 파일이 존재한다거나, 커밋 메세지를 수정하고 싶은 경우에 사용
단, 바로직전에 실행한 commit 수정만 가능하다.

git commit -m "some commit"
git add file
git commit --amend  새 커밋을 생성해 현재 브랜치를 수정하거나 교차하는 것 

